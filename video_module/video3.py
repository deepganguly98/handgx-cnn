# Import 'kivy.core.text' must be called in entry point script
# before import of cv2 to initialize Kivy's text provider.
# This fixes crash on app exit.

import kivy.core.text
import cv2
import numpy as np
from kivy.app import App
from kivy.base import EventLoop
from kivy.uix.image import Image
from kivy.clock import Clock
from kivy.graphics.texture import Texture
from kivy.uix.boxlayout import BoxLayout
from kivy.core.window import Window


class KivyCamera(Image):

    #init function to initialize the capture variable
    def __init__(self, **kwargs):
        super(KivyCamera, self).__init__(**kwargs)
        self.capture = None
    # start function for the first color video to to copy capture from the cv2 module and refresh it at regular intervals using 'update' function
    def start(self, capture, fps=30):
        self.capture = capture
        Clock.schedule_interval(self.update, 1.0 / fps)
    # start2 function for the second gray video to to copy capture from the cv2 module and refresh it at regular intervals using 'update2' function
    def start2(self, capture, fps=30):
        self.capture = capture
        Clock.schedule_interval(self.update2, 1.0 / fps)
    # stops/pauses the video capturing and nullifies the capture variable
    def stop(self):
        Clock.unschedule(self.update)
        self.capture = None
    # same as stop but for the 2nd video
    def stop2(self):
        Clock.unschedule(self.update2)
        self.capture = None
    #handles the preprocessing of the first video creates the texture and adds it to the screen
    #notice texture.blit_buffer used to buffer the video generated by cv2 to synchronise it with kivy display
    #self.canvas.ask_update() refreshes it
    def update(self, dt):
        return_value, frame = self.capture.read()
        frame = cv2.flip(frame, 1)
        cv2.rectangle(frame, (300, 100), (600, 400), (0, 255, 0), 0)
        if return_value:
            texture = self.texture
            w, h = frame.shape[1], frame.shape[0]
            if not texture or texture.width != w or texture.height != h:
                self.texture = texture = Texture.create(size=(w, h))
                texture.flip_vertical()
            texture.blit_buffer(frame.tobytes(), colorfmt='bgr')
            self.canvas.ask_update()
    #same as update just colorfmt (color format) of the texture is luminance check documentation of texture
    #resize to set the size of the video output

    def update2(self, dt):
        return_value, frame = self.capture.read()
        frame = cv2.flip(frame, 1)
        roi = frame[100:400, 300:600]
        gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)
        blur = cv2.GaussianBlur(gray, (31, 31), 0)

        frame = cv2.resize(blur, (128, 128))
        # frame =frame.reshape(128,128,1)
        if return_value:
            texture = self.texture
            w, h = frame.shape[1], frame.shape[0]
            #print('w ='+str(w))
            #print('h = '+str(h))
            if not texture or texture.width != w or texture.height != h:
                self.texture = texture = Texture.create(size=(w, h))
                texture.flip_vertical()
            texture.blit_buffer(frame.tobytes(), colorfmt='luminance')
            self.canvas.ask_update()

#variable to hold the live video frames
capture = None


class QrtestHome(BoxLayout):

    def init_qrtest(self):
        pass
    #servers the start button for both videos (start(video1), start2(video2))
    def dostart(self, *largs):
        global capture
        capture = cv2.VideoCapture(0)
        self.ids.qrcam.start(capture)
        self.ids.qrcam1.start2(capture)

    # servers the stop button for both videos (stop(video1), stop2(video2))
    def dostop(self):
        global capture
        if capture !=None:
            capture.release()
            capture = None
        self.ids.qrcam.stop()
        self.ids.qrcam1.stop2()
    #stops the app
    def doexit(self):
        global capture
        if capture != None:
            capture.release()
            capture = None
        EventLoop.close()
    # changes captured by slider1
    def slider1_change(self, value):
        print("Slider 1 value " + str(value))

    # changes captured by slider2
    def slider2_change(self, value):
        print("Slider 2 value " + str(value))

    # changes captured by slider3
    def slider3_change(self, value):
        print("Slider 3 value " + str(value))


class qrtestApp(App):

    def build(self):
        # to set the background color of the window whivh is black by default
        Window.clearcolor = (.4,.4,.4,1)
        #set the size of the window
        Window.size = (800, 600)
        homeWin = QrtestHome()
        homeWin.init_qrtest()
        return homeWin

    def on_stop(self):
        global capture
        if capture:
            capture.release()
            capture = None

qrtestApp().run()